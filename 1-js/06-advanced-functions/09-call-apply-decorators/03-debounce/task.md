importance: 5

---

# 디바운스 데코레이터

데코레이터 `debounce(f, ms)`의 결과는 래퍼입니다. 이 래퍼는 아무 호출이 없는 `ms` 밀리초의 대기 시간이 끝날 때까지 `f`의 호출을 연기합니다. 그리고서 `f`를 가장 최근에 사용된 인수와 함께 한 번 실행합니다.

예를 들어 함수 `f`를 `f = debounce(f, 1000)`로 바꿨다고 해봅시다.

그런 뒤 래퍼된 함수가 각각 0ms, 200ms, 500ms에서 호출된 후 더 이상의 호출이 없다면 실제 `f`는 1,500ms에서 한 번만 호출됩니다. 즉 마지막 호출로부터 1,000ms의 대기 시간 후에 호출됐다고 할 수 있습니다.

![](debounce.svg)

그리고 대기 시간 후에 호출된 f는 가장 마지막 호출에서 가졌던 인수를 가지며 그전에 있던 호출들은 무시됩니다.

아래에 위 설명을 위한 코드가 있습니다. [Lodash 라이브러리](https://lodash.com/docs/4.17.15#debounce)에 있는 디바운스(debounce) 데코레이터를 사용하였습니다.

```js
let f = _.debounce(alert, 1000);

f("a"); 
setTimeout( () => f("b"), 200);
setTimeout( () => f("c"), 500); 
// 디바운스된 함수는 마지막 호출 이후 1,000ms를 기다린 뒤에 alert("c")를 실행합니다.
```


이제 연습 예제를 살펴봅시다. 사용자가 뭔가를 입력하고 입력이 완료되면 서버에 요청을 보내고 싶다고 가정해봅시다.

글자가 입력될 때마다 이에 대한 요청을 매번 보내는 건 의미가 없습니다. 그 대신 글자 입력이 끝날 때까지 기다린 뒤 얻은 전체 결과를 처리하는 방식이 선호됩니다.

웹 브라우저에서 입력 필드에 변화가 있을 때마다 호출되는 함수인 이벤트 핸들러를 만들 수 있습니다. 이벤트 핸들러는 입력된 키에 반응하므로 보통 매우 빈번히 호출됩니다. 하지만 이벤트 핸들러를 1,000ms로 `디바운스`하면 이 핸들러는 마지막 입력에서 1,000ms이 지난 후에 한 번만 호출됩니다.

```online

아래에 바로 해볼 수 있는 예제에서는 함수 handler가 입력 필드의 결과를 아래 있는 박스에 넣어주도록 설계되었습니다. 직접 해보세요.

[iframe border=1 src="debounce" height=200]

그렇죠? 두 번째 입력 필드는 디바운스된 함수를 부르고 이 함수의 콘텐츠는 마지막 입력에서 1,000ms가 지난 후에 처리됩니다.
```

따라서 `디바운스`는 연속으로 입력되는 키, 마우스 움직임 등 일련의 이벤트를 처리하는데 적합한 방법입니다.


디바운스는 마지막 호출이 끝나고 주어진 시간 동안 기다린 뒤에 결과를 처리하도록 디바우스된 함수를 실행합니다.

이 과제는 `debounce` 데코레이터를 구현해보는 과제입니다.

잘 생각해보면 단 몇 줄만으로도 구현이 가능합니다.