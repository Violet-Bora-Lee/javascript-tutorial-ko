# 숫자형

자바스크립트에 있는 모든 숫자는 '배정밀도 부동소수점 숫자(double precision floating point numbers)'로 알려진 64-비트 형식 [IEEE-754]에 저장되어 있습니다.

현재 알고 있는 내용을 한번 요약해 보겠습니다.

## 숫자를 입력하는 다양한 방법

10억을 입력해야 한다고 상상해 봅니다. 가장 분명한 방법이 있습니다.

```js
let billion = 1000000000;
```

그러나 실제로는 0을 길게 입력하다가는 잘못 입력하기 쉽기 때문에 일반적으로 사용하지 않습니다. 주로 10억 대신 `'1bn'`을 입력하거나 73억 대신에 `'7.3bn'`을 입력합니다. 대부분의 더 큰 수의 경우에도 마찬가지입니다.

자바스크립트에서는 숫자에 `'e'`를 추가하고 0을 지정하여 숫자를 줄입니다.

```js run
let billion = 1e9;  // 10억, 문자 그대로 1과 9개의 0

alert( 7.3e9 );  // 73억 (7,300,000,000)
```

즉, `'e'`는 주어진 수에 e 뒤에 있는 수만큼 10의 거듭제곱을 하는 것입니다.

```js
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```


이제 매우 작은 숫자를 입력해보겠습니다. 1 마이크로초(백만 분의 1초)를 예로 들겠습니다.

```js
let ms = 0.000001;
```

이전처럼 `'e'`가 도와줄 수 있습니다. 0을 명시적으로 쓰고 싶지 않다면 다음과 같이 작성할 수 있습니다.

```js
let ms = 1e-6; // 10의 -6승
```

`0.000001`에서 0을 세면 6개입니다. 그래서 이것은 `1e-6`입니다.  

즉, `'e'`는 주어진 수에 10의 거듭제곱으로 e 뒤에 있는 수만큼 나누는 것을 의미합니다.

```js
// 0을 3개 적고 1의 자리 수부터 3칸 앞으로 이동
1e-3 = 1 / 1000 (=0.001)

// 0을 6개 적고 1의 자리 수부터 6칸 앞으로 이동
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```

### 16진수, 2진수, 8진수 숫자

[16진수](https://en.wikipedia.org/wiki/Hexadecimal) 숫자는 자바스크립트에서 색깔을 나타낼 때, 문자형으로 인코드할 때 그리고 그 외 다양한 부분에서 쓰입니다. 자연스럽게 16진수를 `0x` 그리고 그 뒤에 숫자들로 짧게 입력하는 방법이 있습니다.

예시:

```js run
alert( 0xff ); // 255
alert( 0xFF ); // 255 (이 경우는 같은 것입니다.)
```

2진수와 8진수는 거의 쓰이지 않지만 `0b` 과 `0o` 접두사를 통해 지원합니다.


```js run
let a = 0b11111111; // 255의 2진법
let b = 0o377; // 255의 8진법

alert( a == b ); // true, a == b는 같은 것을 의미합니다.
```

이처럼 3개의 숫자형만 지원합니다. 다른 진법에는 이 챕터에서 나중에 보게 될 `parseInt`라는 함수를 사용해야 합니다.

## toString(base)

`num.toString(base)` 메서드는 `base`의 진법으로 숫자 num이 문자형으로 반환합니다.

예시:
```js run
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base`는 `2`에서 `36`까지 다양합니다. 기본값은 `10`입니다.

아래는 이에 대한 유스 케이스입니다.

- **base=16**는 16진수 색상, 문자 인코딩 등에 쓰이고 숫자는 `0..9` 또는 `A..F`가 될 수 있습니다.
- **base=2**는 대부분 비트 연산 디버깅에 쓰이고 숫자는 `0` 또는 `1`이 될 수 있습니다.
- **base=36**는 최댓값이고 숫자는 `0..9` 또는 `A..Z`가 될 수 있습니다. 알파벳은 숫자를 나타내기 위해 사용합니다. 짧은 url을 만들기 위해 긴 숫자 식별자를 더 짧은 것으로 만들어야 하는 경우 base=36이 유용합니다. `36`을 토대로 진법에서 간단히 나타낼 수 있습니다.

    ```js run
    alert( 123456..toString(36) ); // 2n9c
    ```

```warn header="함수를 불러오기 위한 두 개의 점"
`123456..toString(36)`에 있는 두 개의 점은 오타가 아니라는 점에 유의하세요. 위에 있는 `toString`의 예시처럼 숫자에 함수를 불러오고 싶으면, 숫자 다음에 점 두 개인 `..`를 배치하세요.

`123456.toString(36)`처럼 한 개의 점만 배치하면 이것은 에러일 수 있는데 그 이유는 자바스크립트 문법에서 첫 번째 점 이후 부분은 소수 부분으로 인식하기 때문입니다. 그리고 하나 이상의 점을 배치하면 자바스크립트는 소수 부분이 비어있다는 것을 알고 함수로 이동합니다.

또한 이처럼 `(123456).toString(36)`으로 입력할 수 있습니다.
```

## 반올림

숫자형과 가장 많이 이용하는 연산자 중 하나는 반올림입니다.

반올림에 관한 내장 함수들이 존재합니다.

`Math.floor`
: `3.1`의 소수부를 버렸을 땐 `3`이 되고 `-1.1`은 `-2`가 됩니다.

`Math.ceil`
: `3.1`의 소수부를 버렸을 땐 `4`가 되고 `-1.1`은 `-1`이 됩니다.

`Math.round`
: `3.1`의 반올림은 `3`이 되고 `3.6`은 `4`가 되며 `-1.1`은 `-1`이 됩니다.

`Math.trunc` (Internet Explorer에서는 지원하지 않습니다.)
: 반올림을 하지 않고 소수 부분을 제거합니다. `3.1`은 `3`이 되고 `-1.1`은 `-1`이 됩니다.

아래에는 각 함수의 차이점을 요약해 놓은 테이블이 있습니다.

|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
|---|---------|--------|---------|---------|
|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |
|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |
|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |
|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |


이러한 함수는 소수 부분을 다루기 위한 가능한 모든 방법을 포함합니다. 하지만 만약에 소수 부분을 `n-th`의 숫자 형태로 반올림하고 싶은 경우에는 어떻게 해야 할까요?

예를 들어 `1.2345`가 있고 `1.23`처럼 2개의 숫자 형태로 반올림하고 싶은 경우가 있습니다.

여기 두 가지 방법이 있습니다.

1. 곱하기와 나누기

   예를 들어 숫자를 소수점 이하 두 번째 숫자까지 반올림하려면 숫자에 `100`을 곱하고 반올림 함수를 호출한 다음 다시 나누면 됩니다.
   ```js run
    let num = 1.23456;

    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

2. [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 메서드는 점 다음에 숫자를 'n' 자리로 반올림하고 리턴합니다.

    ```js run
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    ```

    `Math.round`와 가장 비슷한 함수로 반올림하거나 내림합니다.

    ```js run
    let num = 12.36;
    alert( num.toFixed(1) ); // "12.4"
    ```

    `toFixed`의 결과는 문자열입니다. 소수 부분이 필요한 것보다 짧으면 끝에 0이 추가됩니다.

    ```js run
    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", 정확히 5자리를 만들기 위해 0을 추가했습니다.
    ```

    단항 덧셈 연산자 또는 `Number()`를 호출하여 숫자로 변환할 수 있습니다. `+num.toFixed(5)`

## 부정확한 계산

내부적으로 숫자는 64비트 형식 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)으로 표시되므로 숫자를 저장하는 데 정확히 64비트를 사용합니다. 그 중 숫자를 저장하기 위해 52개가 사용됩니다. 11개는 소수점 위치(정수는 0)를 저장하고 1비트는 부호를 저장합니다.

숫자가 너무 크면 64비트 스토리지를 오버플로하여 무한대를 제공 할 수 있습니다.

```js run
alert( 1e500 ); // Infinity
```

자주 발생하지만 불분명한 것은 정확성이 낮아지는 것입니다.

이 (falsy!) 테스트를 고려해보세요.

```js run
alert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*
```

맞습니다. `0.1`과 `0.2`의 합이 `0.3`인지 확인하면 `false`가 됩니다.

이상하죠! `0.3`이 아니라면 무엇일까요?

```js run
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

여기에 잘못된 비교보다 더 많은 결과가 있습니다. 전자 쇼핑 사이트를 만들고 방문자가 `$0.10`와 `$0.20` 물품을 차트에 넣었다고 상상해보세요. 주문 총액은 `$0.30000000000000004`입니다. 이는 누군가를 놀라게 할 것입니다.

왜 이런 일이 발생할까요?

숫자는 이진 형식으로 연속된 비트(1과 0)로 메모리에 저장됩니다. 그러나 10진수에서 쉽게 볼 수 있는 `0.1`, `0.2`와 같은 분수는 실제로 2진수의 끝없는 분수입니다.

다시 말해, `0.1`은 무엇일까요? 1을 10으로 나눈 `1/10`입니다. 10진수에서 이러한 숫자는 쉽게 표현할 수 있습니다. `1/3`과 비교해봅시다. 끝없는 분수`0.33333(3)`이 됩니다.

따라서 `10`의 거듭제곱으로 나누는 것은 10진수에서 잘 작동할 것이 보장되지만 `3`으로 나누는 것은 그렇지 않습니다. 같은 이유로 2진수에서 `2`의 제곱에 의한 나눗셈이 작동하는 것이 보장되지만 `1/10`은 끝없는 2진 분수가 됩니다.

2진수를 사용하여 *정확하게 0.1* 또는 * 정확하게 0.2*를 저장하는 방법은 없습니다. 1/3을 소수로 저장하는 방법이 없는 것과 마찬가지죠.

숫자 형식 IEEE-754는 가능한 가장 가까운 숫자로 반올림하여 이 문제를 해결합니다. 이러한 반올림 규칙은 일반적으로 '작은 정밀 손실'을 볼 수는 없지만 존재합니다.

우리는 이것을 실제로 볼 수 있습니다.
```js run
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

그리고 두 숫자를 합하면 '정밀도 손실'이 더해집니다.

그렇기 때문에 `0.1 + 0.2`가 정확히 `0.3`이 아닙니다.

```smart header="자바스크립트뿐만이 아닙니다."
다른 많은 프로그래밍 언어에서도 동일한 문제가 발생합니다.

PHP, Java, C, Perl, Ruby는 동일한 숫자 형식을 기반으로 하기 때문에 정확히 동일한 결과를 제공합니다.
```

문제를 해결할 수 있을까요? 물론 가장 좋은 방법은 이 함수를 사용하여 결과를 반올림하는 것입니다. [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)

```js run
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

`toFixed`는 항상 문자열을 반환합니다. 소수점 다음에 2자리가 되도록 합니다. 우리가 전자 쇼핑을 하고 `$0.30`을 보여줄 필요가 있다면 편리합니다. 다른 경우에는 단항 덧셈 연산자를 사용하여 숫자로 강제 변환 할 수 있습니다.

```js run
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

또한 일시적으로 숫자에 100 (또는 더 큰 숫자)을 곱하여 정수로 바꾸고 계산을 한 다음 다시 나눌 수 있습니다. 그런 다음 정수로 계산을 수행하면 오류가 다소 줄어들지만, 여전히 나눗셈을 해야 합니다.

```js run
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

따라서 곱하기/나누기 접근 방식은 오류를 줄이지만, 오류를 완전히 제거하지는 않습니다.

때때로 분수를 사용하지 않으려고 할 때가 있습니다. 가게를 다루는 것처럼 가격을 달러 대신 센트로 저장할 수 있습니다. 그러나 30%의 할인을 적용하면 어떻게 될까요? 실제로는 분수를 완전히 피하기가 거의 불가능합니다. 필요할 때 '꼬리'를 자르기 위해 반올림하세요.

````smart header="재미있는 것"
이것을 실행하세요.

```js run
// 저는 스스로 증가합니다.
alert( 9999999999999999 ); // 10000000000000000 을 보여줍니다.
```

이것은 같은 문제, 즉 정밀도의 손실로 어려움을 겪습니다. 숫자에는 64비트가 있으며 그중 52비트는 숫자를 저장하는 데 사용할 수 있지만 충분하지 않습니다. 따라서 가장 작은 유효 숫자가 사라집니다.

자바스크립트는 이러한 이벤트에서 오류를 유발하지 않습니다. 숫자를 원하는 형식으로 맞추는 것이 가장 좋지만, 불행하게도 이 형식은 충분하지 않습니다.
````

```smart header="두 가지의 0"
숫자의 내부 표현의 또 다른 재미있는 결과는 `0`과 `-0`의 두 가지 0이 존재하는 것입니다.

부호가 단일 비트로 표시되므로 0을 포함한 모든 숫자가 양수 또는 음수일 수 있기 때문입니다.

대부분의 연산자는 이를 동일하게 취급하기에 적합하므로 차이가 눈에 띄지 않습니다.
```



## 테스트: isFinite와 isNaN

이 두 특수 숫자 값을 기억하십니까?

- `Infinity`(및 `-Infinity`)는 다른 것보다 큰(작은) 특수 숫자 값입니다.
- `NaN`은 에러를 나타냅니다.

`Infinity`와 `NaN`은 `숫자형`에 속하지만 '정상적인' 숫자는 아니기 때문에 이를 확인하기 위한 특별한 함수가 있습니다.


- `isNaN(value)`는 인수를 숫자로 변환한 다음 `NaN`인지 테스트합니다.

    ```js run
    alert( isNaN(NaN) ); // true
    alert( isNaN("str") ); // true
    ```

    이 함수가 필요할까요? `=== NaN` 비교를 사용할 수 없을까요? 안타깝게도 대답은 '아니요'입니다. `NaN`의 값은 다음을 포함하여 아무것도 같지 않다는 점에서 독특합니다. 

    ```js run
    alert( NaN === NaN ); // false
    ```

- `isFinite(value)`는 인수를 숫자로 변환하고 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환합니다.

    ```js run
    alert( isFinite("15") ); // true
    alert( isFinite("str") ); // false, NaN이기 때문입니다.
    alert( isFinite(Infinity) ); // false, Infinity이기 때문입니다.
    ```

때때로 `isFinite`는 문자열이 정규 숫자인지 확인하는 데 사용됩니다.


```js run
let num = +prompt("Enter a number", '');

// Infinity, -Infinity를 입력하거나 숫자를 입력하지 않으면 true입니다.
alert( isFinite(num) );
```

`isFinite`를 포함한 모든 숫자 함수에서 비어 있거나 공백 전용 문자열은 '0'으로 처리됩니다. 

```smart header="`Object.is`와 비교하기"

`===`와 같이 값을 비교하는 특수 내장 메서드 [Object.is](mdn:js/Object/is)가 있지만 두 가지 에지 케이스에 더 안정적입니다.

1. `Object.is`는 `NaN`과 함께 작동합니다. `Object.is(NaN, NaN) === true`, 좋은 방법입니다.
2.`0`과`-0`의 값은 다릅니다.`Object.is(0, -0) === false`, 내부적으로 숫자는 다른 모든 경우에도 다를 수 있는 부호 비트를 갖기 때문에 0일지라도 사실입니다.

다른 모든 경우에,`Object.is(a, b)`는`a === b`와 같습니다.

이 비교 방법은 종종 자바스크립트 설명서에서 사용됩니다. 내부 알고리즘이 정확히 같은 두 값을 비교해야 하는 경우 `Object.is`(내부적으로 [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)라고 함)를 사용합니다.
```


## parseInt와 parseFloat

더하기 `+` 또는 `Number()`를 사용한 숫자 변환은 엄격합니다. 값이 정확히 숫자가 아닌 경우 실패합니다.

```js run
alert( +"100px" ); // NaN
```

유일한 예외는 문자열의 시작 또는 끝의 공백에서 무시 될 때의 경우입니다.

그러나 실제로는 CSS에서 `'100px'`또는 `'12pt'`와 같은 값을 단위로 사용합니다. 또한, 많은 국가에서 통화 기호가 금액 뒤에 옵니다. 따라서 `'19€'`가 있으며 그로부터 숫자를 추출하려고 합니다.

이것이 바로 `parseInt`와 `parseFloat`입니다.

그들은 할 수 없을 때까지 문자열에서 숫자를 '읽습니다'. 오류가 있는 경우 수집된 번호가 반환됩니다. `parseInt`함수는 정수를 반환하는 반면, `parseFloat`함수는 부동 소수점 숫자를 반환합니다.

```js run
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점은 무시합니다.
```

`parseInt/parseFloat`가 `NaN`을 리턴하는 상황이 있습니다. 읽을 수 있는 숫자가 없을 때 발생합니다.

```js run
alert( parseInt('a123') ); // NaN, a는 프로세스가 중지됩니다.
```

````smart header="`parseInt(str, radix)`의 두 번째 인수"
 `parseInt()`함수에는 선택적으로 두 번째 매개 변수가 있습니다. radix는 숫자 시스템의 밑을 지정하므로, `parseInt`는 16진수, 2진수 등의 문자열을 구문 분석 할 수 있습니다.

```js run
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, 0x가 없어도 작동합니다.

alert( parseInt('2n9c', 36) ); // 123456
```
````

## 다른 수학 함수

자바스크립트에는 작은 수학 함수 및 상수 라이브러리가 포함된 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 객체가 내장되어 있습니다.

몇 가지 예시:

`Math.random()`
: 0에서 1 사이의 난수를 반환합니다. (1 제외)

    ```js run
    alert( Math.random() ); // 0.1234567894322
    alert( Math.random() ); // 0.5435252343232
    alert( Math.random() ); // ... (무작위 수)
    ```

`Math.max(a, b, c...)` / `Math.min(a, b, c...)`
: 임의의 개수의 인수에서 최대/최소를 반환합니다.

    ```js run
    alert( Math.max(3, 5, -10, 0, 1) ); // 5
    alert( Math.min(1, 2) ); // 1
    ```

`Math.pow(n, power)`
: power를 n제곱한 것을 반환합니다.

    ```js run
    alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
    ```

`Math` 객체에는 삼각법을 포함하여 더 많은 함수와 상수가 있습니다. 삼각법은 [Math객체를 위한 문서](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math)에서 찾을 수 있습니다.

## 요약

큰 숫자를 쓰려면

- 숫자가 0인 `'e'`를 추가합니다. `123e6`은 6개의 0을 가진 `123`입니다.
- `'e'`다음의 음수는 주어진 0으로 숫자를 1로 나눕니다. 백만 분의 일 등을 나타내기 위해 사용됩니다.

다른 숫자의 경우

- 16진수 (`0x`), 8진수 (`0o`) 및 2진수 (`0b`)에서 직접 숫자를 쓸 수 있습니다.
- `parseInt(str, base)`는 `base`가 `2 ≤ base ≤ 36`인 숫자에서 문자열 `str`를 구문 분석합니다.
- `num.toString(base)` 는 주어진 `base`를 사용하여 진법 체계에서 숫자를 문자열로 변환합니다.

`12pt` 및 `100px`와 같은 값을 숫자로 변환하는 경우

문자열에서 숫자를 읽은 다음 에러가 발생하기 전에 읽을 수 있는 값을 반환하는 '소프트' 변환에 `parseInt/parseFloat`를 사용하세요.

분수의 경우

- `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` 또는`num.toFixed(precision)`을 사용하여 반올림하세요.
- 분수로 작업할 때 정밀도가 떨어짐을 기억하세요.

더 많은 수학 함수

- 필요할 때 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 객체를 참조하세요. 라이브러리는 매우 작지만 기본적인 요구를 충족시킬 수 있습니다.
