
# 심볼 타입(Symbol type)

명세에 따르면 객체의 프로퍼티 키는 문자열 타입이나 심볼 타입이 될 수 있습니다. 숫자나 boolean 타입은 불가능하며 오직 문자열과 심볼 두 타입만 가능합니다.

지금까지는 문자열만 접해봤는데 이제 심볼을 사용하면 좋은 점에 대해 알아봅시다.

## 심볼(Symbols)

"심볼(Symbol)" 값은 유일한 식별자를 나타냅니다.

심볼 값은 `Symbol()`를 통해 만들어집니다.

```js
// id는 새로운 심볼입니다.
let id = Symbol();
```

심볼에 설명(심볼 이름이라고도 불립니다)을 붙일 수도 있습니다. 주로 디버깅을 할 때 유용하게 쓰입니다.

```js run
// id는 "id"라는 설명을 가진 심볼입니다.
let id = Symbol("id");
```

심볼은 유일하다는 것이 보장됩니다. 같은 설명을 가진 많은 심볼을 만들지라도, 그 심볼들은 다른 값을 가집니다. 설명은 어떤 것에도 영향을 주지 않는 라벨일 뿐입니다.

예를 들어, 여기에 같은 설명을 가진 두 심볼이 있습니다. -- 이들은 같지 않습니다.

```js run
let id1 = Symbol("id");
let id2 = Symbol("id");

*!*
alert(id1 == id2); // false
*/!*
```

여러분이 루비(Ruby)나 "심볼"과 비슷한 것을 가진 다른 언어와 친숙하다면 -- 잘못 이해하면 안 됩니다. 자바스크립트의 심볼은 다릅니다.

````warn header="심볼은 문자열로 자동 변환되지 않습니다."
자바스크립트의 대부분의 값은 문자열로의 암시적 형 변환을 지원합니다. 예를 들어, 어느 값에나 `alert`를 사용할 수 있으며 코드는 잘 실행됩니다. 그러나 심볼은 특별합니다. 심볼은 자동 변환되지 않습니다.

예를 들어, 이 코드의 `alert`는 에러를 일으킬 것입니다.

```js run
let id = Symbol("id");
*!*
alert(id); // TypeError: Cannot convert a Symbol value to a string
*/!*
```

만약 정말로 심볼을 보여주고 싶다면, 다음과 같이 심볼에 `.toString()` 메서드를 호출해야 합니다.
```js run
let id = Symbol("id");
*!*
alert(id.toString()); // Symbol(id), 이제 잘 실행됩니다.
*/!*
```

이것은 혼란을 막기 위한 "언어적 보호장치"입니다. 문자열과 심볼은 근본적으로 다를 뿐만 아니라 일반적으로 서로의 타입으로 변환돼선 안 되기 때문입니다.
````

## "숨겨진" 프로퍼티

심볼을 통해 객체의 "숨겨진" 프로퍼티를 만들 수 있습니다. 다른 영역에 있는 어떤 코드도 숨겨진 프로퍼티에 접근하거나 다른 값을 덮어쓸 수 없습니다.

예를 들어 우리가 `user` 객체에 "식별자"를 저장하고 싶다면, 심볼을 키로 사용할 수 있습니다.

```js run
let user = { name: "John" };
let id = Symbol("id");

user[id] = "ID Value";
alert( user[id] ); // 우리는 심볼을 키로 사용해 데이터에 접근할 수 있습니다.
```

`"id"`라는 문자열을 사용하지 않고 `Symbol("id")`을 사용하면 어떤 점이 좋을까요?

이를 알아보기 위해 더 자세한 예제를 다뤄 봅시다.

다른 스크립트 코드에서 `user` 안에 "id" 프로퍼티를 만들어 사용한다고 상상해 봅시다. 다른 자바스크립트 라이브러리에서 그럴 수도 있습니다. 따라서 서로 다른 스크립트는 서로의 존재를 전혀 알지 못합니다.

이러한 상황에서 스크립트는 자체적으로 `Symbol("id")`을 만들어 사용할 수 있습니다.

```js
// ...
let id = Symbol("id");

user[id] = "Their id value";
```

심볼은 같은 이름을 가질지라도 항상 고유한 존재이기 때문에 충돌이 발생하지 않는 것입니다.

만약 같은 목적으로 심볼 대신에 `"id"`라는 문자열을 사용했다면 **충돌이 발생하게 된다**는 것에 주목해 주세요.

```js run
let user = { name: "John" };

// 이 스크립트는 "id" 프로퍼티를 사용합니다.
user.id = "ID Value";

// ...만약 이후에 다른 스크립트에서 "id"를 사용한다면...

user.id = "Their id value"
// 이런! 값이 덮어 쓰이게 됩니다! 다른 스크립트를 손상하려 한 것은 아니지만, 뜻대로 되지 않네요.
```

### 객체 리터럴 내 심볼

객체 리터럴에서 심볼을 사용하고 싶다면 대괄호를 사용해야 합니다.

이렇게 말이죠.

```js
let id = Symbol("id");

let user = {
  name: "John",
*!*
  [id]: 123 // "id: 123"가 아닙니다.
*/!*
};
```
문자열 "id"가 아니라 키로 사용하는 `id` 변수의 값을 얻고자 하는 것이기 때문에 대괄호를 사용해야 합니다.

### 심볼은 for..in 에서 배제됩니다.

심볼 프로퍼티는 `for..in` 반복문에서 나타나지 않습니다.

예를 들어:

```js run
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

*!*
for (let key in user) alert(key); // name, age (심볼은 없습니다.)
*/!*

// 심볼로 직접 접근을 하면 잘 작동합니다.
alert( "Direct: " + user[id] );
```

이것은 일반적으로 "알려지지 않은" 개념입니다. 다른 스크립트나 라이브러리에서 사용자가 만든 객체에 반복문을 돈다면, 예기치 못하게 심볼 프로퍼티에 접근하지 못할 것입니다.

반면 [Object.assign](mdn:js/Object/assign) 는 문자열과 심볼 프로퍼티 모두 복사할 수 있습니다.

```js run
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

이것은 모순된 것이 아니라, 사실 계획된 일입니다. 객체를 복사하거나 병합할 때, 일반적으로 사람들은 (`id`와 같은 심볼을 포함한) *모든* 프로퍼티를 복사하고 싶어 한다는 생각에서 비롯된 것입니다.

````smart header="다른 타입의 프로퍼티 키는 문자열로 강제 변환됩니다."
객체의 키로 문자열과 심볼 타입만 사용할 수 있습니다. 다른 타입은 문자열로 변환됩니다.

예를 들어, 숫자 `0`을 프로퍼티 키로 사용하면 문자열 `"0"`이 됩니다.

```js run
let obj = {
  0: "test" // "0": "test"와 동일합니다.
};

// 아래 두 alert 문은 같은 프로퍼티에 접근합니다. (숫자 0이 문자열 "0"으로 변환됩니다.)
alert( obj["0"] ); // test
alert( obj[0] ); // test (같은 프로퍼티)
```
````

## 전역 심볼

앞에서 봤던 것처럼 일반적으로 심볼은 같은 이름을 가졌을지라도 서로 다른 존재입니다. 하지만 같은 이름을 가진 심볼이 같은 개체이길 바랄 때가 가끔 있습니다.

예를 들어, 애플리케이션의 서로 다른 부분에서 똑같은 프로퍼티인 `"id"` 심볼에 접근한다고 가정해 봅시다.

이를 위해, *전역 심볼 레지스트리(global symbol registry)*가 존재합니다. 전역 심볼 레지스트리 안에 심볼을 생성하고 나중에 접근할 수 있습니다. 같은 이름으로 여러 번 접근해도 언제나 같은 심볼을 반환하는 것이 보장됩니다.

레지스트리 안에서 심볼을 생성하거나 읽기 위해서는 `Symbol.for(key)`를 사용합니다.

이 메서드는 전역 레지스트리를 확인하고 만약 `key`로 설명되는 심볼이 존재하면 그 심볼을 반환합니다. 심볼이 존재하지 않으면 주어진 `key`를 통해 `Symbol(key)`이라는 새로운 심볼을 생성하고 레지스트리 안에 저장합니다.

예를 들어

```js run
// 전역 레지스트리에서 심볼을 읽어 옵니다.
let id = Symbol.for("id"); // 만약 심볼이 존재하지 않는다면, 새로운 심볼을 생성합니다.

// 다시 한번 심볼을 읽어 옵니다.
let idAgain = Symbol.for("id");

// 이 둘은 같은 심볼입니다.
alert( id === idAgain ); // true
```

전역 심볼 레지스트리 안에 있는 심볼을 *전역 심볼*이라고 합니다. 애플리케이션 전체에서 사용하거나 코드 내 어디서나 접근 가능한 심볼이 필요할 때 -- 바로 전역 심볼을 사용하면 됩니다.

```smart header="루비랑 비슷해 보이네요."
루비같은 몇몇 프로그래밍 언어에서는 심볼마다 고유의 이름이 존재합니다.

이 사실은 자바스크립트에 오게 되면 전역 심볼에만 해당됩니다.
```

### Symbol.keyFor

전역 심볼에 사용되는 `Symbol.for(key)`는 주어진 키로 심볼을 찾아 반환하는데, 이와 반대로 호출할 수도 있습니다. `Symbol.keyFor(sym)`를 사용하면 주어진 심볼에 대한 키를 반환합니다.

예를 들어

```js run
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// 심볼 키 반환
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

`Symbol.keyFor`는 주어진 심볼의 키를 찾기 위해 내부적으로 전역 심볼 레지스트리를 사용합니다. 따라서, 전역 심볼이 아닌 심볼에는 사용할 수 없습니다. 만약 전역 심볼이 아니라면, 심볼을 찾을 수 없어 `undefined`를 반환합니다.

예를 들어

```js run
alert( Symbol.keyFor(Symbol.for("name")) ); // name, 전역 심볼

alert( Symbol.keyFor(Symbol("name2")) ); // undefined, 매개변수는 전역 심볼이 아닙니다.
```

## 시스템 심볼

자바스크립트가 내부적으로 사용하는 "시스템" 심볼이 많이 있습니다. 객체를 다양하게 활용하기 위해 시스템 심볼을 사용할 수 있습니다.

[잘 알려진 심볼](https://tc39.github.io/ecma262/#sec-well-known-symbols) 명세에 시스템 심볼이 나와 있습니다.

- `Symbol.hasInstance`
- `Symbol.isConcatSpreadable`
- `Symbol.iterator`
- `Symbol.toPrimitive`
- ...등등

예를 들어 `Symbol.toPrimitive`는 객체를 원시 값으로 변환합니다. 이것의 사용 사례를 곧 다룰 예정입니다.

다른 심볼들도 해당하는 기능을 공부할 때 다룰 것입니다.

## 요약

`Symbol`은 유일한 식별자를 위한 원시 타입입니다.

심볼은 추가적인 설명과 함께 `Symbol()` 호출로 생성됩니다.

심볼은 같은 이름을 가질지라도 항상 다른 값을 갖습니다. 만약 같은 이름을 가진 심볼이 같은 값을 갖기를 원한다면, 전역 레지스트리를 사용해야 합니다. `Symbol.for(key)`는 `key`라는 이름을 가진 전역 심볼을 반환합니다(필요하다면 생성합니다). `Symbol.for`를 여러 번 호출해도 언제나 같은 심볼을 반환합니다.

심볼의 주요 사용 사례로는 두 가지가 있습니다.

1. "숨겨진" 객체 프로퍼티
    다른 스크립트나 라이브러리에 "소속된" 객체에 프로퍼티를 추가하고 싶다면, 심볼을 만들어 그것을 프로퍼티 키로 사용할 수 있습니다. 심볼 프로퍼티는 `for..in`에 등장하지 않습니다. 또한 직접적으로 접근할 수도 없습니다. 한 스크립트는 다른 스크립트에서 사용하는 심볼을 알 수 없기 때문입니다.

    따라서 어떤 것을 심볼 프로퍼티로 "변환하여" 원하는 객체 안에 숨길 수 있으며, 다른 스크립트들은 이것을 볼 수 없습니다.

2. 자바스크립트가 사용하는 많은 시스템 심볼이 있으며 `Symbol.*`로 시스템 심볼에 접근할 수 있습니다. 시스템 심볼을 통해 내장된 몇몇 특성을 변경할 수 있습니다. 예를 들어, 이후 챕터에서 [iterable](info:iterable)에 `Symbol.iterator`를 사용하거나 [객체에서 원시 타입으로의 변환](info:object-toprimitive)을 위해 `Symbol.toPrimitive` 등을 사용할 것입니다.

기술적으로 보면 심볼은 100% 숨겨진 것이 아닙니다. 모든 심볼을 보여주는 [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols)라는 내장 메서드가 존재합니다. 또한 심볼 프로퍼티를 포함하여 객체의 모든 키를 반환하는 [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys)라는 메서드도 존재합니다. 그러므로 심볼은 정말로 숨겨진 존재가 아닙니다. 하지만 대부분의 라이브러리, 내장 메서드, 구문 구조는 심볼이 숨겨진 존재라는 합의를 지키고 있습니다. 그리고 앞에서 말한 메서드를 명백히 호출하는 사람은 아마 자신이 하고 있는 일을 잘 이해할 것입니다.
